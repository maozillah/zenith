<html>
	<head>
		<title>zenith</title>
		<style>
            canvas { width: 100%; height: 100% }
            body { width: 100%; height: 100%; margin: 0; padding: 0; height: 100%;
				overflow:hidden;}
            
            a {
                color: #fff;
                background: rgba(255, 255, 255, 0.2);
                text-decoration: none;
                padding: 15px;
                border-radius: 7px;
                text-align: center;
            }
            
            #splashscreen {
                position:absolute;
                top:0;
                left:0;
                bottom:0;
                width:100%;
                color: #fff;
                background-color:black;
            }
            
            #starName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }

        </style>
	</head>
    
	<body>
<!--
        <div id="splashscreen">
       
                <h1>Zenith</h1>
                An interactive constellations view
                <br/><br/><a href="#" class="explore" onclick="moveCam();">Explore</a>
            
        </div>
-->
        <div id="starName">No star hovered</div>
        
		<script src="js/three.min.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script> <!-- neccessary or not to pull in this library? -->
        <script src="js/jquery-csv.min.js"></script>
        <script src="js/tween.min.js"></script>
		<script>
            var scene, camera, renderer, axes;
            var projector, mouseVector;
            var starData, stars, INTERSECTED;
            var windowx = window.innerWidth;
            var windowy = window.innerHeight;
 
            
            $( document ).ready(function() {
                $.get( "data/constellation_data.csv", function( data ) {
                    starData = $.csv.toArrays(data);
                    console.log("csv ready!");
                    
                    // splashscreen
                    $('.explore').click(function () {
                        $(this).parent('#splashscreen').fadeOut(500);
                    });
                    
                    //starData[1][7]
                    
                    init();
                });
            });

            function init(){
                if ( !Detector.webgl ) Detector.addGetWebGLMessage();
                scene = new THREE.Scene();
                

                //we need to see the world
                camera = new THREE.PerspectiveCamera(50, windowx/windowy, 0.1, 1000);
                camera.position.set(0,10,100);

                //we need to update the display
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(windowx, windowy);
         
                document.body.appendChild(renderer.domElement);
                
                //let there be light
                
                         var light	= new THREE.AmbientLight( 0x888888 );
	scene.add( light );
                
                var light = new THREE.SpotLight( 0xCCCCCC, 1, 0, Math.PI, 1);
                light.position.set(20,50,50);
                scene.add(light);
                
                // earth woo
                geometry = new THREE.SphereGeometry(1, 30, 30);
                material = new THREE.MeshLambertMaterial( {color:0x0000ff});
                var earth = new THREE.Mesh(geometry, material);  
                earth.position.set(0, 0, 0);
                scene.add(earth);
                
                
                // map negative absolute magnitude ranges
                function map_range(value, low1, high1, low2, high2) {
                    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
                }

                //draw spheres for each star in the constellation based off csv data
                geometry = new THREE.SphereGeometry(1, 30, 30);
               
                stars = new THREE.Object3D();
                scene.add( stars );
                        
                for (var i = 1; i < starData.length; i++) {
                    star = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color:0x00ffff})); 
                    // map magnitude for brightness, parseFloat(starData[i][2])
                    
                    star.position.x = parseFloat(starData[i][4]) * 0.8; 
                    star.position.y = parseFloat(starData[i][5]) * 0.8;
                    star.position.z = parseFloat(starData[i][6]) * 0.8;
                    
//                    geometry.vertices.push( star.position );
                    
                    star.name=starData[i][7] + " " + starData[i][8];
                    
                    // for magnitude, the more negative a number, the brighter MAKE NEGATIVE Inverse problem
                    var invertedAbsoMag = -parseFloat(starData[i][3]);
                    
                    // from asbolute magnitude, don't forget to change range values
                    var absoMag = map_range(invertedAbsoMag, -3.297647909, 2.304163211 , 0, 1.5);
                    
                    star.scale.set(absoMag,absoMag,absoMag);

                    stars.add(star);
                }
                
                // lines                          
                
                material = new THREE.LineBasicMaterial({color: 0x00ffff});
                geometry = new THREE.Geometry();
                geometry.vertices.push(
                    new THREE.Vector3( -10, 0, 0 ),
                    new THREE.Vector3( 0, 15, 15 ),
                    new THREE.Vector3( 10, 0, 0 ),
                    new THREE.Vector3( 15, 10, 0 )
                );
                var line = new THREE.Line( geometry, material );
                scene.add( line );
                

                projector = new THREE.Projector(); //do i need a variable for this?
                mouseVector = new THREE.Vector3();
                
                // On hover
                window.addEventListener( 'mousemove', onMouseMove, false );
                
                function onMouseMove( e ) {
		
                    // label
                    var label = document.getElementById("starName");
                    
                    mouseVector.x = 2 * (e.clientX / windowx) - 1;
                    mouseVector.y = 1 - 2 * ( e.clientY / windowy );

                    var raycaster = projector.pickingRay( mouseVector.clone(), camera ),
                        intersects = raycaster.intersectObjects( stars.children );
                    
                    // check if intersecting with star
                    if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                        // yes intersecting do this
						INTERSECTED.material.emissive.setHex( 0xff0000 );

                         // mouse position for label
                        var x = event.clientX;  
                        var y = event.clientY; 
                        
                        label.innerHTML = INTERSECTED.name;
                        label.style.top = y+20 + 'px';
                        label.style.left = x+20 + 'px';
                        label.style.display = "initial";
					}

				} else {
					if ( INTERSECTED ) {INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                                       label.style.display = "none";}
					INTERSECTED = null;
				}       

                }
                            
                // camera controls
                controls = new THREE.OrbitControls(camera);
                render();
                
                 // Axes
                axes = buildAxes();
                scene.add( axes );
            }
            
            // animations
            function moveCam(){

                    var pos1 = new TWEEN.Tween(camera.position).to({z:-200, x: 200}, 8000).easing(TWEEN.Easing.Quadratic.InOut);
                    var rot1 = new TWEEN.Tween(camera.rotation).to({y:-3}, 8000).easing(TWEEN.Easing.Quadratic.InOut); //rotation in radians, 3.14 = full 180
                    
                pos1.chain(rot1); //connect 
                pos1.start();
            }

            //render scene 60 fps
			function render() {
				requestAnimationFrame(render);

                camera.lookAt (scene.position);
                
                //for labels
                camera.updateMatrixWorld();
                
				renderer.render(scene, camera);
                controls.update();
                
                TWEEN.update();
                
			}
            
            // http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                function buildAxes() {
                    var axes = new THREE.Object3D();

                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

                    return axes;

                }

                function buildAxis( src, dst, colorHex, dashed ) {
                    var geom = new THREE.Geometry(),
                        mat; 

                    if(dashed) {
                        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
                    } else {
                        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
                    }

                    geom.vertices.push( src.clone() );
                    geom.vertices.push( dst.clone() );

                    var axis = new THREE.Line( geom, mat );

                    return axis;

                }

		</script>
	</body>
</html>