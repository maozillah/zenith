<html>
	<head>
		<title>zenith</title>
		<style>
            canvas { width: 100%; height: 100% }
            body { width: 100%; height: 100%; margin: 0; padding: 0; height: 100%;
				overflow:hidden;}
            
            a {
                color: #fff;
                background: rgba(255, 255, 255, 0.2);
                text-decoration: none;
                padding: 15px;
                border-radius: 7px;
                text-align: center;
            }
            
            #splashscreen {
                position:absolute;
                top:0;
                left:0;
                bottom:0;
                width:100%;
                color: #fff;
                background-color:black;
            }
            
            #starName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }
            
            #lineName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }

        </style>
	</head>
    
	<body>
<!--
        <div id="splashscreen">
       
                <h1>Zenith</h1>
                An interactive constellations view
                <br/><br/><a href="#" class="explore" onclick="moveCam();">Explore</a>
            
        </div>
-->
        <div id="starName">No star hovered</div>
        <div id="lineName">No constellation hovered</div>
        
		<script src="js/three.min.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script> <!-- neccessary or not to pull in this library? -->
        <script src="js/jquery-csv.min.js"></script>
        <script src="js/tween.min.js"></script>
		<script>
            var scene, camera, renderer, axes;
            
            //raycasting
            var projector, raycaster;
            var mouse = new THREE.Vector2(), INTERSECTED, currentIntersected;
            var sceneLines, intLines;
            
            var starData, lineData, stars, outerGlow;
            var windowx = window.innerWidth;
            var windowy = window.innerHeight;
            var positionScale = 0.9;
 
            
            $( document ).ready(function() {
                $.get( "data/constellation_data.csv", function( data ) {
                    starData = $.csv.toArrays(data);
                    console.log("constellation data ready!");
                    
                    $.get( "data/line_order.csv", function( data ) {
                    lineData = $.csv.toArrays(data);
                    console.log("line data ready!");
                        
                        init();
                    });
                    
                });
                                
             // splashscreen
                $('.explore').click(function () {
                    $(this).parent('#splashscreen').fadeOut(500);
                });       
                    //starData[1][7]

            });

            function init(){
                if ( !Detector.webgl ) Detector.addGetWebGLMessage();
                scene = new THREE.Scene();
                

                //we need to see the world
                camera = new THREE.PerspectiveCamera(50, windowx/windowy, 0.1, 1000);
                camera.position.set(0,10,100);

                //we need to update the display
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(windowx, windowy);
         
                document.body.appendChild(renderer.domElement);
                
                //let there be light
                
                var light	= new THREE.AmbientLight( 0x888888 );
	           scene.add( light );
                
                var light = new THREE.SpotLight( 0xCCCCCC, 1, 0, Math.PI, 1);
                light.position.set(20,50,50);
                scene.add(light);
                
                // earth woo
                geometry = new THREE.SphereGeometry(0.5, 32, 32);
                material  = new THREE.MeshPhongMaterial();
                var earth = new THREE.Mesh(geometry, material);  
                earth.scale.set(0.5,0.5,0.5);
                earth.position.set(0, 0, 0);
                
                 material.map    = THREE.ImageUtils.loadTexture('imgs/earthmap.jpg'); // map color texture to sphere
                
                //map bump
                material.bumpMap    = THREE.ImageUtils.loadTexture('imgs/earthbump1k.jpg'); 
                material.bumpScale = 0.08;
                
                //specular light, only shiny things are water
                material.specularMap    = THREE.ImageUtils.loadTexture('imgs/earthspec1k.jpg');
                material.specular  = new THREE.Color('grey');
                
                scene.add(earth);
                                
                var geometry   = new THREE.SphereGeometry(0.51, 32, 32);
                var material  = new THREE.MeshPhongMaterial({
                   // map     : new THREE.Texture(canvasCloud), //load texture from?
                  map     : THREE.ImageUtils.loadTexture('imgs/earthcloudmap.png'),
                  side        : THREE.DoubleSide,
                  opacity     : 0.8,
                  transparent : true,
                  depthWrite  : false,
                });
                var cloudMesh = new THREE.Mesh(geometry, material);
                earth.add(cloudMesh);
                
                
                //galaxy
                var geometry  = new THREE.SphereGeometry(90, 32, 32);
                var material  = new THREE.MeshBasicMaterial();
                var galaxy = new THREE.Mesh(geometry, material);
                
                material.map   = THREE.ImageUtils.loadTexture('imgs/galaxy.png');
                material.side  = THREE.BackSide; //inside of sphere
                // create the mesh based on geometry and material
                var mesh  = new THREE.Mesh(geometry, material);
                scene.add(galaxy);
                
                
                // map negative absolute magnitude ranges
                function map_range(value, low1, high1, low2, high2) {
                    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
                }

                //draw spheres for each star in the constellation based off csv data
                geometry = new THREE.SphereGeometry(1, 30, 30);
               
                stars = new THREE.Object3D();
                scene.add( stars );
                
                outerGlow = new THREE.Object3D();
                scene.add( outerGlow );
                
                var spriteMaterial = new THREE.SpriteMaterial( 
                { 
                    map: new THREE.ImageUtils.loadTexture( 'imgs/glow.png' ), 
                    color: 0xCCFFFF, transparent: false, blending: THREE.AdditiveBlending
                });
                        
                for (var i = 1; i < starData.length; i++) {
                    var sprite = new THREE.Sprite( spriteMaterial );
                    
                    star = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color:0x99FFCC, transparent: true, opacity : 0.5})); 
                    // map magnitude for brightness, parseFloat(starData[i][2])
                    
                    star.position.x = parseFloat(starData[i][4] *positionScale); 
                    star.position.y = parseFloat(starData[i][5] *positionScale);
                    star.position.z = parseFloat(starData[i][6] *positionScale);
                    
                    sprite.position.set(star.position.x, star.position.y, star.position.z);
//                    star.name=starData[i][7] + " " + starData[i][8];
                    
                    sprite.name = starData[i][8];
                    star.name=starData[i][7];

                    // for magnitude, the more negative a number, the brighter MAKE NEGATIVE Inverse problem
                    
                    // from asbolute magnitude, don't forget to change range values. NEED INVERT MATRIX
                    var absoMag = map_range(parseFloat(starData[i][3]), -3.297647909, 2.304163211 , 0, 1.5) * 0.5;
                    var glowMag = absoMag*4;

                    star.scale.set(absoMag,absoMag,absoMag);
                    sprite.scale.set(glowMag, glowMag, glowMag);

                    stars.add(star);
                    outerGlow.add(sprite);
                }
                
                // draw lines for constellations
                sceneLines = new THREE.Object3D();
                scene.add(sceneLines);
                
                intLines = new THREE.Object3D();
                
                function drawLines(constellation, constName) {                   
                    var linegeometry = new THREE.Geometry();
                    material = new THREE.LineBasicMaterial({color: 0xffffff, transparent: true, opacity : 0.2});

                    for (var h = 1; h < lineData[constellation].length; h++) {
                        linegeometry.hip = lineData[constellation][h];

                        for (var i = 1; i < starData.length; i++) {
                        star.hip = starData[i][0]; //constellation name

                            if (star.hip == linegeometry.hip) {
                                star.position.x = parseFloat(starData[i][4] *positionScale); 
                                star.position.y = parseFloat(starData[i][5] *positionScale);
                                star.position.z = parseFloat(starData[i][6] *positionScale);

                                linegeometry.vertices.push( star.position.clone() );
                            }
                        }  		
                }

                var lines = new THREE.Line( linegeometry, material );
                var lines2 = new THREE.Line( linegeometry, material );
                lines.name = constName;
                lines2.name = constName;
                sceneLines.add( lines );
                intLines.add( lines2 );

                }
                
                drawLines(0, "Aries"); // aries
                drawLines(1, "Capricorn"); //capricorn

        
                // raycasting

                projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();
                
                // User interaction
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                
                function onDocumentMouseMove( event ) {
                    
                    event.preventDefault();
                    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
                    // label
                    var starlabel = document.getElementById("starName");

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );

                    raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                    var intersects = raycaster.intersectObjects( stars.children );
                
                     // mouse position for label
                    var x = event.clientX;  
                    var y = event.clientY; 
                    
                    // check if intersecting with star
                    if ( intersects.length > 0 ) {
                        if ( INTERSECTED != intersects[ 0 ].object ) {

                            INTERSECTED = intersects[ 0 ].object;
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            // yes intersecting do this
                            INTERSECTED.material.opacity= 0.9;

                            starlabel.innerHTML = INTERSECTED.name;
                            starlabel.style.top = y+20 + 'px';
                            starlabel.style.left = x+20 + 'px';
                            starlabel.style.display = "initial";
                        }

                    } else {
                        if ( INTERSECTED ) {INTERSECTED.material.opacity= 0.5;
                                           starlabel.style.display = "none";}
                        INTERSECTED = null;
                    }       
                    
                    //line variables
                    var linelabel = document.getElementById("lineName");
                    var lineintersects = raycaster.intersectObjects( sceneLines.children, true);
                    
                    //check if intersecting with line
                    if ( lineintersects.length > 0 ) {

                        if ( lineintersects[ 0 ].object != currentIntersected ) {

                            currentIntersected = lineintersects[ 0 ].object;
                            currentIntersected.material.opacity= 0.6;
                            
                            linelabel.innerHTML = currentIntersected.name;
                            linelabel.style.top = y-50 + 'px';
                            linelabel.style.left = x-50 + 'px';
                            linelabel.style.display = "initial";
                            
                        }

                    } else {

                        if ( currentIntersected ) {currentIntersected.material.opacity= 0.2;
                                                   linelabel.style.display = "none";}
                       currentIntersected = null;

                    } 

                }
                            
                // camera controls
                controls = new THREE.OrbitControls(camera);
                controls.zoomSpeed = 0.1;
                render();
                
                 // Axes
                axes = buildAxes();
                scene.add( axes );
            }
            
            // modal
            document.onmousedown = function(e) {
                
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                var intersects = raycaster.intersectObjects( outerGlow.children );
                
                // check if intersecting with star
                    if ( intersects.length > 0 ) {
                        if ( INTERSECTED != intersects[ 0 ].object ) {
                            INTERSECTED = intersects[ 0 ].object;
                            console.log(INTERSECTED.name);
                        }

                    } else {
//                        if ( INTERSECTED ) {INTERSECTED.material.opacity= 0.5;
//                                           starlabel.style.display = "none";}
                         if ( INTERSECTED ) {}
                        INTERSECTED = null;
                    }     
                
                // check if intersecting with lines
                var lineintersects = raycaster.intersectObjects( intLines.children, true);
                    
                    //check if intersecting with line
                    if ( lineintersects.length > 0 ) {

                        if ( lineintersects[ 0 ].object != currentIntersected ) {

                            currentIntersected = lineintersects[ 0 ].object;
                            console.log(currentIntersected.name);
                            
                        }

                    } else {

//                        if ( currentIntersected ) {currentIntersected.material.opacity= 0.2;
//                                                   linelabel.style.display = "none";}
                       currentIntersected = null;

                    } 
            }
            
            // animations
            function moveCam(){

                    var pos1 = new TWEEN.Tween(camera.position).to({z:-200, x: 200}, 8000).easing(TWEEN.Easing.Quadratic.InOut);
                    var rot1 = new TWEEN.Tween(camera.rotation).to({y:-3}, 8000).easing(TWEEN.Easing.Quadratic.InOut); //rotation in radians, 3.14 = full 180
                    
                pos1.chain(rot1); //connect 
                pos1.start();
            }

            //render scene 60 fps
			function render() {
				requestAnimationFrame(render);

                camera.lookAt (scene.position);
                
                //for labels
                camera.updateMatrixWorld();
                
				renderer.render(scene, camera);
                controls.update();
                
                TWEEN.update();
                
			}
            
            // http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                function buildAxes() {
                    var axes = new THREE.Object3D();

                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

                    return axes;

                }

                function buildAxis( src, dst, colorHex, dashed ) {
                    var geom = new THREE.Geometry(),
                        mat; 

                    if(dashed) {
                        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
                    } else {
                        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
                    }

                    geom.vertices.push( src.clone() );
                    geom.vertices.push( dst.clone() );

                    var axis = new THREE.Line( geom, mat );

                    return axis;

                }

		</script>
	</body>
</html>