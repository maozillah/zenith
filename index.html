<html>
	<head>
		<title>zenith</title>
		<style>
            canvas { width: 100%; height: 100% }
            body { width: 100%; height: 100%; margin: 0; padding: 0; height: 100%;
				overflow:hidden;}
            
            a {
                color: #fff;
                background: rgba(255, 255, 255, 0.2);
                text-decoration: none;
                padding: 15px;
                border-radius: 7px;
                text-align: center;
            }
            
            #splashscreen {
                position:absolute;
                top:0;
                left:0;
                bottom:0;
                width:100%;
                color: #fff;
                background-color:black;
            }
            
            #starName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }
            
            #lineName { 
                position: absolute;
                top: 0px; 
                left: 0px;
				padding: 5px;
                background-color: #faffd5;
                display: none;
            }

        </style>
	</head>
    
	<body>
<!--
        <div id="splashscreen">
       
                <h1>Zenith</h1>
                An interactive constellations view
                <br/><br/><a href="#" class="explore" onclick="moveCam();">Explore</a>
            
        </div>
-->
        <div id="starName">No star hovered</div>
        <div id="lineName">No constellation hovered</div>
        
		<script src="js/three.min.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script> <!-- neccessary or not to pull in this library? -->
        <script src="js/jquery-csv.min.js"></script>
        <script src="js/tween.min.js"></script>
		<script>
            var scene, camera, renderer, axes;
            
            //raycasting
            var projector, raycaster;
            var mouse = new THREE.Vector2(), INTERSECTED, currentIntersected;
            var sceneLines;
            
            var starData, lineData, stars;
            var windowx = window.innerWidth;
            var windowy = window.innerHeight;
            var positionScale = 0.9;
 
            
            $( document ).ready(function() {
                $.get( "data/constellation_data.csv", function( data ) {
                    starData = $.csv.toArrays(data);
                    console.log("constellation data ready!");
                    
                    $.get( "data/line_order.csv", function( data ) {
                    lineData = $.csv.toArrays(data);
                    console.log("line data ready!");
                        
                        init();
                    });
                    
                });
                                
             // splashscreen
                $('.explore').click(function () {
                    $(this).parent('#splashscreen').fadeOut(500);
                });       
                    //starData[1][7]

            });

            function init(){
                if ( !Detector.webgl ) Detector.addGetWebGLMessage();
                scene = new THREE.Scene();
                

                //we need to see the world
                camera = new THREE.PerspectiveCamera(50, windowx/windowy, 0.1, 1000);
                camera.position.set(0,10,100);

                //we need to update the display
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(windowx, windowy);
         
                document.body.appendChild(renderer.domElement);
                
                //let there be light
                
                         var light	= new THREE.AmbientLight( 0x888888 );
	scene.add( light );
                
                var light = new THREE.SpotLight( 0xCCCCCC, 1, 0, Math.PI, 1);
                light.position.set(20,50,50);
                scene.add(light);
                
                // earth woo
                geometry = new THREE.SphereGeometry(1, 30, 30);
                material = new THREE.MeshLambertMaterial( {color:0x0000ff});
                var earth = new THREE.Mesh(geometry, material);  
                earth.scale.set(0.5,0.5,0.5);
                earth.position.set(0, 0, 0);
                scene.add(earth);
                
                
                // map negative absolute magnitude ranges
                function map_range(value, low1, high1, low2, high2) {
                    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
                }

                //draw spheres for each star in the constellation based off csv data
                geometry = new THREE.SphereGeometry(1, 30, 30);
               
                stars = new THREE.Object3D();
                scene.add( stars );
                        
                for (var i = 1; i < starData.length; i++) {
                    star = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color:0x00ffff})); 
                    // map magnitude for brightness, parseFloat(starData[i][2])
                    
                    star.position.x = parseFloat(starData[i][4] *positionScale); 
                    star.position.y = parseFloat(starData[i][5] *positionScale);
                    star.position.z = parseFloat(starData[i][6] *positionScale);
                    
                    star.name=starData[i][7];
//                    star.name=starData[i][7] + " " + starData[i][8];

                    
                    // for magnitude, the more negative a number, the brighter MAKE NEGATIVE Inverse problem
                    
                    // from asbolute magnitude, don't forget to change range values. NEED INVERT MATRIX
                    var absoMag = map_range(parseFloat(starData[i][3]), -3.297647909, 2.304163211 , 0, 1.5) * 0.5;
                    
                    star.scale.set(absoMag,absoMag,absoMag);
                    
//                    scene.add( star ); 
 
                    stars.add(star);
                }
                
                // draw lines for constellations
                sceneLines = new THREE.Object3D();
                scene.add(sceneLines);
                
                function drawLines(constellation, constName) {                   
                    var linegeometry = new THREE.Geometry();
                    material = new THREE.LineBasicMaterial({color: 0x00ffff});

                    for (var h = 1; h < lineData[constellation].length; h++) {
                        linegeometry.hip = lineData[constellation][h];

                        for (var i = 1; i < starData.length; i++) {
                        star.hip = starData[i][0]; //constellation name

                            if (star.hip == linegeometry.hip) {
                                star.position.x = parseFloat(starData[i][4] *positionScale); 
                                star.position.y = parseFloat(starData[i][5] *positionScale);
                                star.position.z = parseFloat(starData[i][6] *positionScale);

                                linegeometry.vertices.push( star.position.clone() );
                            }
                        }  		
                }

                var lines = new THREE.Line( linegeometry, material );
                lines.name = constName;
                 sceneLines.add( lines );

                }
                
                drawLines(0, "Aries"); // aries
                drawLines(1, "Capricorn"); //capricorn

        
                // raycasting

                projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();
                
                // User interaction
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                
                function onDocumentMouseMove( event ) {
                    
                    event.preventDefault();
                    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
                    // label
                    var starlabel = document.getElementById("starName");

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );
//                    projector.unproject( vector, camera );

                    raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                    var intersects = raycaster.intersectObjects( stars.children );
                
                     // mouse position for label
                    var x = event.clientX;  
                    var y = event.clientY; 
                    
                    // check if intersecting with star
                    if ( intersects.length > 0 ) {
                        if ( INTERSECTED != intersects[ 0 ].object ) {
                            if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                            INTERSECTED = intersects[ 0 ].object;
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            // yes intersecting do this
                            INTERSECTED.material.emissive.setHex( 0xff0000 );

                            starlabel.innerHTML = INTERSECTED.name;
                            starlabel.style.top = y+20 + 'px';
                            starlabel.style.left = x+20 + 'px';
                            starlabel.style.display = "initial";
                        }

                    } else {
                        if ( INTERSECTED ) {INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                                           starlabel.style.display = "none";}
                        INTERSECTED = null;
                    }       
                    
                    //line variables
                    var linelabel = document.getElementById("lineName");
                    var lineintersects = raycaster.intersectObjects( sceneLines.children, true);
                    
                    //check if intersecting with line
                    if ( lineintersects.length > 0 ) {

                        if ( lineintersects[ 0 ].object != currentIntersected ) {

                            if ( currentIntersected ) currentIntersected.material.color.setHex( currentIntersected.currentHex );
                            currentIntersected = lineintersects[ 0 ].object;
                            currentIntersected.currentHex = currentIntersected.material.color.getHex();

                             currentIntersected.material.color.setHex( 0xff0000 );
                            
                            linelabel.innerHTML = currentIntersected.name;
                            linelabel.style.top = y-50 + 'px';
                            linelabel.style.left = x-50 + 'px';
                            linelabel.style.display = "initial";
                            
                        }

                    } else {

                        if ( currentIntersected ) {currentIntersected.material.color.setHex( currentIntersected.currentHex );
                                                   linelabel.style.display = "none";}
                       currentIntersected = null;

                    } 

                }
                            
                // camera controls
                controls = new THREE.OrbitControls(camera);
                render();
                
                 // Axes
                axes = buildAxes();
                scene.add( axes );
            }
            
            // animations
            function moveCam(){

                    var pos1 = new TWEEN.Tween(camera.position).to({z:-200, x: 200}, 8000).easing(TWEEN.Easing.Quadratic.InOut);
                    var rot1 = new TWEEN.Tween(camera.rotation).to({y:-3}, 8000).easing(TWEEN.Easing.Quadratic.InOut); //rotation in radians, 3.14 = full 180
                    
                pos1.chain(rot1); //connect 
                pos1.start();
            }

            //render scene 60 fps
			function render() {
				requestAnimationFrame(render);

                camera.lookAt (scene.position);
                
                //for labels
                camera.updateMatrixWorld();
                
				renderer.render(scene, camera);
                controls.update();
                
                TWEEN.update();
                
			}
            
            // http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                function buildAxes() {
                    var axes = new THREE.Object3D();

                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
                    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

                    return axes;

                }

                function buildAxis( src, dst, colorHex, dashed ) {
                    var geom = new THREE.Geometry(),
                        mat; 

                    if(dashed) {
                        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
                    } else {
                        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
                    }

                    geom.vertices.push( src.clone() );
                    geom.vertices.push( dst.clone() );

                    var axis = new THREE.Line( geom, mat );

                    return axis;

                }

		</script>
	</body>
</html>